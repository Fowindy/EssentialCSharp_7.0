3.0 序言
	1.讨论将数据元素合并成元组的细节_C# 7.0新增;
	2.讨论如何将数据分组到称为数组的集合中;
3.1 类型的划分_值类型和引用类型的根本区别
	1.值类型:总是拷贝值本身;
	2.引用类型:总是拷贝该值的引用(地址);
3.1.1 值类型
	1.预定义类型除了string其他均为值类型;
	2.值类型直接包含值_变量引用的位置就是内存中实际存储的位置;
	3.在方法内部对参数值进行任何修改都不会影响调用函数中的原始值;
	4.占用内存比引用类型多;
3.1.2 引用类型
	1.引用类型的变量存储对数据存储位置的引用,而不是直接存储数据;
	2.访问数据,要先从变量中读取内存位置,再跳转到包含数据的内存位置;
	3.为引用类型的变量分配实际数据的内存区域成为堆(heap)
	4.拷贝引用类型的实例比拷贝大的值类型实例更高效;
	5.两个不同的变量可引用相同的数据;其中一个变量更改对象字段,用另一个对象访问字段将看到更改的结果;
	
	何时使用值类型和引用类型?
	对象在逻辑上是固定大小,不可变的值---定义成值类型
	对象在逻辑上是可引用,可变的东西---定义引用类型

3.2 可空修饰符
	1.不能将null值赋值给值类型,值类型不能包含引用;
	2.为了能存储null的变量,要使用可空修饰符?

	$引用类型的局部变量
	1.C# 3.0新增上下文关键字var来声明隐式类型的局部变量
	2.虽允许用var取代数据类型,但数据类型已知情况下最好不使用var
	3.使用var变量时,右侧数据类型应显而易见,否则避免使用var声明变量;

	*设计规范:避免使用隐式类型的局部变量,除非所赋的值的数据类型显而易见;

	语言对比:C++/VB/JavaScript void*和var
	隐式类型变量不等价于C++的void*,VB的Variant或JavaScript的var
	类似于C#将变量声明为Object类型
	C#的var由编译器严格确定类型,确定了就不能变,类型检查和成员调用都会在编译时进行验证;

	高级主题:匿名类型
	C# 3.0添加var的真正目的是支持匿名类型
	匿名类型:匿名类型是在方法内部动态声明的数据类型;
	C# 7.0引入元组语法后,匿名类型基本被代替;

3.3 元组(tuple)
	允许在一个语句中完成所有变量的赋值;
	(string country,string capital,double gdpPerCapital)=("Malawi","Lilongwe",226.50);

	设计规范:元组
	1.要为元组语法的变量声明使用camelCase大小写规范;
	2.考虑为所有元组项名称使用PascalCase大小写风格。

	高级主题: System.ValueTuples...>类型
	编译器查找元组生命中的项名称,并允许代码访问还在作用域中的项;

3.4 数组
	1.利用数组声明,可在单个变量中存储同一种类型的多个数据项,而且可利用索引来单独访问这些数据项。
	2.C#的数组索引从零开始;

	初学者主题:数组
	1.可用数组变量声明同类型多个数据项的集合,每一项都用名为索引的整数值进行唯一标识;
	2.C#数组的第一个数据项使用索引0访问
	3.由于索引基于零,应确保最大索引值比数组中的数据项总数小1
	4.初学者可将索引想象成偏移量

	大多数程序现在都用泛型集合类型而非数组来存储数据集合;
	数组的重点:
	1.声明多维数组要使用逗号,逗号数量+1=维数
	string[] Languages; // one-dimensional
	int[,] cells;// two-dimensionat
	2.赋值
	  string[] languages = { "C#", "COBOL", "Java", "C++", "Visual Basic", "Pascal", "Fortran", "Lisp", "J#" };
      languages = new string[9];
      languages = new string[] { "C#", "COBOL", "Java", "C++", "Visual Basic", "Pascal", "Fortran", "Lisp", "J#" };
      //多维数组赋值和初始化(二维)
      int[,] cells = new int[2, 3] { {0,1,2},{1,2,3}}; 
	3.default关键字
	使用default表达式显式获取任何数据的默认值
	int count = default(int);
	4.访问数组
	数组基于零,第一个元素的索引是0,用方括号存储和获取数组数据

3.4.1 数组的声明
	1.C#用方括号声明数组变量。首先指定数组元素的类型,后跟一对方括号,再输入变量名;
	数组声明的说明:
	1.数组声明的第一部分标识了数组中存储的元素的类型;
	2.方括号指定了数组的秩( rank),或者说维;
	3.类型和维数构成了languages变量的数据类型。

	语言对比:C++和Java---数组的声明
	1.C#中,方括号紧跟在数据类型之后,而不是在变量声明之后,所有类型信息都在一起;
	2.C++和Java那样分散于标识符前后

	二维数组的解析:
	int[,] cells;
	1.第一维对应行,第一维对应列;
	2.数组总维数等于逗号数加1

3.4.2 数组实例化和赋值
	声明数组后,可在一对大括号中使用以逗号分隔的数据项列表来填充它的值
	
	声明数组时new关键字的作用:
	new关键字的作用是指示“运行时”为数据类型分配内存;

	指定数组大小注意事项:
	指定的数组大小必须和大括号中的元素数量匹配;
	string[] languages = new string[9]{ "C#","COBOL","Java","C++","Visual Basic",
    "Pascal","Fortran","Lisp","J#"};

	分配数组不指定初始值的默认值:
	引用类型:null
	数值类型:0
	bool类型:false
	char类型:\0

	不需要在使用数组前初始化它的所有元素

	C#2.0后的特性:使用default()操作符获取数据类型的默认值
	default(int)返回0
	default(bool)返回false

	初始化二维整数数组注意事项:
	数组包含三个int[]类型的元素,每个元素大小一样;int[]元素的大小必须完全一样
	int[,] cells = {
	{ 1,0,2},
    { 1,2,0},
    { 1,2,1}
            };

	多维数组和交错数组的比较:
	多维数组(也称为“矩形数组”)每一维的大小必须一致;
	交错数组不需要具有一致的大小;

	交错数组特点:
	1.交错数组不用逗号标识新维;
	2.交错数组定义由数组构成的数组;
	3.int[]后添加[],表明数组元素是int[]类型的数组;
	4.交错数组要求为内部的每个数组都创建数组实例;

3.4.3 数组的使用
	使用方括号(称为数组访问符)访问数组元素,为获取第一个元素,要指定0作为索引;

	多维数组的元素用每一个维的索引来标识

	交错数组索引讲解:
	第一个索引指定“由数组构成的数组"中的一个数组
	第二个索引指定是该数组中的哪一项

	数组的长度讲解:
	1.数组长度固定,除非重新创建数组,否则不能随便更改;
	2.Length成员返回数组元素个数,而不是返回最高索引值;
	3.最高索引值=Length-1;

	语言对比:C++ 缓冲区溢出错误
	缓冲区溢出:非托管C++并非总是检查是否越过数组边界;
	C#消除了托管代码中发生缓冲区溢出的可能;

	避免数组越界的方式:
	1.应使用长度检查来验证数组长度大于0.
	2.访问数组最后一项时,使用Length-1而不是硬编码的值

	多维数组的元素个数计算方法:
	int[,,] numbers = new int[2,3,3];
	numbers.Length = 2*3*3 = 18

	交错数组的长度:
	Length返回外部数组的元素数;

	-20代表左对齐20字符,\t代表制表符
	            Console.WriteLine(
                $"{ "-------------",-20 }\t{ "------------",-20 }");