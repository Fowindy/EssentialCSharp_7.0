1.C#的基本类型
C#有大量数据类型,可以合并类型创建新类型
基本类型:8种整数类型,2种科学计算的二进制浮点型,1种金融计算的十进制浮点类型,1种布尔类型,1种字符类型;
2.C#基本数值类型
	包括整数类型,浮点类型,decimal类型(能无误的存储大数字)
	8种整型,恰当使用避免浪费资源
		sbyte: 8位有符号
		byte:	8位无符号
		short:	16位有符号
		ushort:	16位无符号
		int:	32位有符号
		uint:	32位无符号	后缀u
		long:	64位有符号	后缀l
		ulong:	64位无符号	后缀ul
3.语言对比:C++的short类型
	C/C++的short是short int的缩写
	C#的short是实际存在的类型
4.浮点类型(float和double:二进制浮点类型)
	浮点类型的精度由有效数位的个数决定
	float: 32位单精度	7位有效数位	后缀f
	double:	64位双精度	15~16位有效数位	后缀d
5.decimal类型(十进制浮点类型)
	decimal:	128位	28~29位有效位	后缀m
	decimal类型所有十进制数都是精确的
	decimal比浮点类型精度高,但范围小,从浮点型转decimal可能会溢出报错,decimal计算速度比浮点型慢(可忽略)
6.高级主题:浮点类型和decimal类型比较
	decimal类型在范围和精度限制内的十进制数完全准确
	浮点数类型使用二进制表示十进制数,可能有精度误差(比如0.1,表示分数为1/10,但是分母10不能表示2的整数次幂,所以有精度误差)
7.字面值
	字面值:源码中的固定值
8.硬编码
	直接将值放到源代码中称为硬编码,慎用;推荐从外部源获取值;方便后续维护不需要重新编译,如果硬编码则需要重新编译
	小数点	默认		double
	整数		默认		int
	大整数	默认		long
9.decimal
	要显示完整精度的数字,必须在字面值显式声明为decimal类型,加m后缀实现
10.字面值的解析顺序
	无后缀:int-->uint-->long---ulong
	后缀u:uint-->ulong
	后缀l:long-->ulong
	后缀ul/lu:ulong
	设计规范:要使用大写的字面后缀
11.16进制记数法
	每个数位可用16个符号表示:0~9,A~F(允许小写)
	16进制和10进制转换不会改变数本身,改变的只是表示形式
	每个16进制数位都用4个二进制位表示,所以一个字节(byte)8位二进制位2位16进制位
	16进制字面值表示:加0x前缀
12.二进制记数法
	二进制字面值表示:加前缀0b(允许大写B)
13.高级主题:将数字格式化成十六进制
	要显示十六进制,必须使用x或X数值格式化说明符(大小写决定十六进制字母大小写)
	Console.WriteLine($"0x{42:X}");
	42可随便使用十进制或者二进制形式,格式说明符之前要加冒号:
14.高级主题:round-trip格式化
	Console.WriteLine(string.Format("{0:R}", 1.618033989749895));
	输出 1.618033989749895 不会丢失精度
15.string.Compare()可以比较两个字符串是否相等(false:忽略大小写)
            int comparison = string.Compare("/HElp", "/Help", false);
            Console.WriteLine(comparison==1?"相同":"不同");
16.布尔类型(bool)
	虽然理论上一个二进制足以容纳一个布尔类型的值,但bool实际大小是一个字节(8位)
17.字符类型(char)
	字符类型:16位	两个字节		取值范围:Unicode字符集
	char的大小和16位无符号整数相同(uint),取值范围:0~65535
	char是C#的特有类型
18.初学者主题:Unicode标准
	Unicode:字符国际标准,表示大多数语言中的字符
19.高级主题:16位不足以表示所有Unicode字符
	随着支持语言的增多,有些Unicode字符需要用一对"代理项"的char构成,32位
	char字面值:需要将字符放到单引号中,eg:'A'
20.转义序列
	转义序列:反斜杠和特殊字符的代码统称
	eg:
	\n---换行
	\t---制表符
	\\---反斜杠符
	\'---单引号
	\r---回车
	\"---双引号
21.Unicode编码表示字符
	Unicode编码可以表示任何字符.加\u前缀,可用十六进制表示Unicode字符
	Unicode为16位二进制 每个十六进制=四个二进制 一个Unicode用4个16进制表示
22.字符串
	零或多个字符的有限序列称为字符串;
	@前缀进行逐字:指明转义序列不被处理(连空格也会逐字解释),@开头的字符串唯一支持转义序列是"",代表一个双引号,不会终止字符串
	$前缀进行字符串插值
	string是一种"不可变"类型
	双引号要用转义序列输出,否则会被用于定义字符串的开始和结束
	语言对比:C++____C#在编译时连接字符串+,C++不用
	"Good"
	"Morning"
	C++直接连接,C#需要使用+操作符连接

	相同字符串在程序集中多次出现,只分配一个空间,只占用一个大小
23.高级主题:理解字符串插值的内部工作原理
	字符串插值是调用string.Format()方法的语法糖
	Console.WriteLine($"Your full name is {firstName} {lastName}.")
	内部等价于如下C#代码:
	object[] args = new object[] {firstName,lastName};
	Console.WriteLine(String.Format("Your full name is {0} {1}.",args));
24.静态方法和实例方法的调用
	静态方法:以类型名作为前缀,在方法名(如Compare)之前附加方法所在类型的名称(如string)
	实例方法:以变量名(或者对实例的其他引用)作为前缀
25.using static指令的引用
	调用System.Console.WriteLine();可以引用Using static指令后直接使用WriteLine();
	1.using static指令需添加到文件顶部(namespace声明之前),优点:每次使用System.Console类成员,可省略System.Console前缀
	2.using static指令只支持静态方法和属性,不支持实例成员;
	3.using指令用于省略命名空间前缀(如System,作用于整个文件)
	4.using static指令仅作用于静态成员
	5.使用using不管实例化还是静态调用等,都可以省略对命名空间的引用;
26.字符串格式化
	string.Format("{0,20:C2}",price);  <==> $"{price,20:C2}"
	小数点后四舍五入保留两位,20个字符宽度右对齐(左对齐就为20添加负号)
27.换行符
	Windows系统的换行符:\r和\n两个字符的组合;
	UNIX系统的换行符:\n
	解决平台兼容性:
	方法1:System.Console.WriteLine()自动输出空行
	方法2:System.Console.WriteLine("Hello World"); <==> System.Console.Write("Hello World" + System.Environment.NewLine);
	Windows系统的等价关系:
	System.Console.WriteLine(); <==> System.Console.Write(System.Envoronment.NewLine); <==> System.Console.Write("\r\n");

	设计规范总结:
	依赖System.Console.WriteLine()和System.Envoronment.NewLine来保证跨平台的兼容性
28.C#属性
	C#允许像访问成员变量(C#中称为字段)那样访问属性
	属性定义:赋值方法(setter)和取值方法(getter)
29.字符串长度
	字符串长度不能直接设置,是根据字符数决定的;
	字符串长度不能更改,因为字符串不可变性
30.字符串的不可变性
	可为字符串全新赋值,但是不能修改现有字符串;
31.System.Text.StringBuilder可变
	大量字符串修改建议使用System.Text.StringBuilder
32.null
	null可赋值给:引用类型,指针类型,可控值类型(表明为空,不指向任何位置)
33.引用类型
	引用类型的变量包含的只是对实际数据所在地址(位置)的引用,而不包含实际数据;
34.void
	void表示无类型或没有任何值
	void本质上不是数据类型,只是指出没有数据类型

	void_语言对比:C++
	相同点,都有两层含义:
	1.标记方法不返回任何数据;
	2.代表指向未知类型的存储位置的一个指针

	void_语言对比:Visual Basic--返回void相当于定义子程序
2.4.数据类型转换
	1.转型
	2.强制类型转换
	显式转型:有可能造成数据丢失或引发异常的任何转换都需要执行显式转型(高转低)
	隐式转型:不会丢失数据,不会引发异常的任何转换都可以进行隐式转型

	高级主题:checked和unchecked的转换
	特殊关键字标识代码块,指出假定目标数据类型太小以至容不下所赋值的数据,会发生什么情况;默认情况悄悄溢出;
	checked代码块:会检查,并显示引发的异常;
	unchecked代码块:不检查,不显示引发的异常;
	unchecked高于checked
	int.MaxValue == 2147483647
	加1变成-2147483648
	原因是:二进制的回绕语义造成的;int.MaxValue的二进制是:01111111111111111111111111111111
	首尾0是符号位:代表正数;加1会触发回绕,下一个值二进制为:10000000000000000000000000000000
	即最小的整数,首位1代表负值
	转型操作符不是万能药,比如不能long转换成bool

	语言对比:C#不允许数值转换成布尔值的好处
	C#为了避免用户本应使用相等操作符时使用了赋值操作符;
	比如:if(x==42){...}写成if(x=42){...}

2.4.2.隐式转型
	不会发生精度丢失,而且值也不会发生根本性改变,代码只需指定赋值操作符,转换隐式发生称为隐式转换;

2.4.3.不使用转型操作符的类型转换_Parse()
	每个数值数据类型都包含一个Parse()方法,允许将字符串转换成对应的数值类型
	1.System.Convert只支持只支持少量类型,且不可扩展,允许从bool, char, sbyte, short,int,long,ushort,uint
	,float,double,decimal,DateTime和string转换到这些类型种的任何一种
	2.所有类型都支持ToString()方法,可用转换为字符串表示
	3.大多数类型的ToString()方法只是返回数据类型的名称,而不是数据的字符串表示,
	只有在类型显式实现了ToString()的前提下才会返回字符串表示

	高级主题:TryParse()
	.NET 2.0开始,所有基元数值类型都包含静态TryParse()方法,与Parse()方法相似
	只是转换失败不是引发异常,二十返回false

	4.out参数的讲解
	bool b = double.TryParse(input,out number)
	此方法从输入的字符串转换到值成功则返回true给b,再通过out将转换成功的值返回给number
	C# 7.0起不用先声明只准备作为out参数使用的变量
	if (double.TryParse(input,out double number)){}
	注意:先写out再写数据类型,定义的number变量只在if语句内部的作用域,在外部不可用

	5.Parse()和TryParse()的关键区别
	如转换失败,TryParse()不会引发异常,Parse()会引发异常;